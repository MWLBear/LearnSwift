

    理解:
    
    在SpriteKit坐标系中原点(0, 0)在左下角
    
    父控件的anchorPoint决定在父坐标系的中心点在哪里
    (0.5,0.5)表示原点在自身的中心点
    
    子控件的anchorPoint表示的是, position是以自身的某个位置为参考,
    以此来确定自身在父坐标系中位置
    
    
---
        

     
     作为第一个参数，您可以指定节点名称或搜索模式。如果您广泛使用XML，您将注意到相似之处：

     • /name：在层次结构的根目录中搜索名为“名称”的节点。

     • //name：搜索名为“名称”的节点，从根开始，递归移动

     等级森严。

     • *：匹配零个或更多字符；例如，名称*将匹配名称1、名称2、名称ABC和名称。

     enumerateChildNodes(withName:using:)返回一个数组，其中包含与您要查找的名称或模式匹配的所有节点，而childNode(withName:)则找到与给定名称或搜索模式匹配的第一个节点。
     
---

     以下是物理体上其余属性的快速浏览：

     •friction：这设置了物体的“滑动性”。值从0.0（身体像冰块一样沿着表面平稳滑动）到1.0（身体沿着表面滑动时快速减速和停止不等。默认值为0.2。

     • isDynamic：有时您想使用物理体进行碰撞检测，但通过手动移动或操作自行移动节点。如果这是你想要的，只需将 isDynamic 设置为 false，物理引擎将忽略物理主体上的所有力量和脉冲，并允许您自己移动节点。

     •usesPreciseCollisionDetection：默认情况下，SpriteKit不执行精确的碰撞检测，因为通常最好牺牲一些精度来实现更快的性能。然而，这有一个副作用：如果一个物体像子弹一样移动得非常快，它可能会穿过另一个物体。如果发生这种情况，请尝试打开此标志，以便进行更准确的碰撞检测。

     •allowsRotation：您可能有一个精灵，您希望物理引擎模拟，但绝不旋转。如果是这样的话，只需将此标志设置为false。
     
     •线性偏振和角偏振：这些值会影响线性速度（翻译）或角速度（旋转）随时间下降的程度。值可以从速度从未下降的0.0到速度立即下降的1.0不等。默认值为0.1。

     • affectedByGravity：默认情况下，所有物体都受到重力的影响，但您只需将其设置为false即可关闭物体。

     •resting：物理引擎有一个优化，其中一段时间没有移动的对象被标记为“休息”，因此物理引擎不再需要对它们进行计算。如果您需要手动“唤醒”休息对象，只需将此标志设置为false。

     •质量和面积：这些是根据物理体的形状和密度自动为您计算的。然而，如果您需要手动覆盖质量，您可以。这个区域是只读的。

     •node：物理主体有一个方便的指针返回它所属的SKNode。这是一个只读属性。

     •categoryBitMask、collisionBitMask、contactTestBitMask和joins：您将在第9章“中级物理”和第10章“高级物理”中了解所有这些。
     
     
---
     
     SpriteKit的默认行为是所有物理物体与所有其他物理物体碰撞。如果两个物体占据同一点，如砖头和猫床，物理引擎将自动将其中一个移到一边。
     1.定义类别：第一步是为您的物理身体定义类别，如块状体、猫体和猫床体。
     2.设置categoryBitMask：一旦您拥有一组类别，您需要指定每个物理主体所属的类别，因为物理主体可以属于多个类别。您只需设置其类别位掩码即可做到这一点。
     3.设置collisionBitMask：您还需要为每个物理体指定碰撞位掩码。这控制着身体将与哪些类别的身体碰撞。
     
     
     检测身体之间的contact
     您已经学会了使用categoryBitMask来设置物理体的类别，并使用collisionBitMask来设置物理体的碰撞类别。嗯，还有另一个位掩码：contactTestBitMask。
     您使用contactTestBitMask来定义当物理物体与另一个物体接触时，应该调用哪些类别的物体，从而调用物理联系人委托方法。
     很容易将collisionBitMask与contactTestBitMask混淆。请记住，碰撞是指物理模拟自动处理的内容（即当物体相互弹跳时），而接触仅指两个物体相互接触时。
     
---

    Joints
    
    Fixed joint:
    固定的接头使您能够将两个物理体连接在一起。想象一下，你有两个物体，你用几根生锈的钉子把它们钉在一起。如果你拿一个物体扔它，另一个物体会跟着它飞。
    有时，你想让一个物体不可移动。最快的方法是将其修复到场景的边缘循环中，你就可以开始了。
    其他时候，你想要一个玩家可以摧毁的复杂物体——也许可以分解成许多碎片。如果是这样的话，只需将碎片固定在一起，当玩家击中物体时，取下关节，使碎片碎片散架。
    
    Limit joint:
    您可以使用极限关节来设置两个物理物体之间的最大距离。虽然这两个身体可以移动得更近，但它们的距离永远不会比你指定的距离更远。
    将极限关节想象成连接两个物体的柔软但结实的绳子。在下图中，球通过极限关节连接到正方形；它可以弹跳，但它永远不会移动得比极限关节的长度更远。
    当您想连接两个对象时，这些类型的接头非常有用，但让一个移动,在一定半径内独立于另一半径内——就像拴着皮带的狗！
    
    Spring joint:
    弹簧接头很像极限接头，但连接更像橡皮筋：弹性和弹性。
    弹簧接头可用于模拟绳索连接，特别是弹性绳索。如果你的游戏中有一个蹦极跳英雄，春季关节会很有帮助！
    
    Pin joint:
    销接头围绕某一点固定两个物理体，即接头的锚点。两个物体都可以围绕锚点自由旋转——当然，如果它们不碰撞的话。
    将销接头想象成一颗大螺丝，可以将两个物体紧密地固定在一起，但仍然允许它们旋转：
    如果你要制造时钟，你会用针接头将手固定在刻度盘上；如果你想为飞机建造一个物理体，你会用针接头将螺旋桨固定在飞机的鼻子上

    Sliding joint:
    滑动接头将两个物理体固定在轴上，它们可以沿着轴自由滑动；您可以进一步定义两个物理体在沿着轴滑动时彼此之间的最小和最大距离。
    这两个相连的物体表现得好像在轨道上移动，它们之间的距离有限：
    如果您正在构建过山车游戏，并且您需要两个汽车物体留在赛道上，但要彼此保持一定的距离，滑动接头可能会派上用场。

---

    SKConstraint.orient(to:offset:)生成一个约束对象，该对象会自动更改其应用该对象的节点的zRotation，以便节点始终指向另一个“目标”节点。
    如果您不想以完美的精度定位节点，您也可以为约束提供偏移范围。由于您希望绳子的末端和钩子紧密相连，因此您为约束提供了零范围。
    除了SpriteKit外，您还可以在SpriteKit中创建许多其他类型的约束
    更多：
    • positionX(_:), positionY(_:) 和 positionX(_:y:)。这些允许您将精灵的位置限制在x轴、y轴或两者的一定范围内。例如，您可以使用这些来限制精灵在屏幕上某个矩形内的移动。


    •orient（to point:offset）和orient（to：in：offset：）。就像你可以让一个精灵把自己指向另一个精灵一样，当你让绳子把自己指向钩子时，
    你可以让一个精灵总是把自己指向某个点。例如，您可以使用这些来使炮塔指向用户点击的位置。

    • distance(_:to node:), distance(_:to point:) and distance(_:to point:in node).这些允许您确保两个节点或一个节点和一个点始终彼此保持一定距离。该函数类似于极限关节，但这些作用在任何节点上，无论它是否有物理体。

---

    • SKCropNode：此节点允许您屏蔽节点的内容，包括其子节点。当您想裁剪部分纹理时，这非常有用。
    • SKVideoNode：此节点允许您在游戏中包含视频。正如您可能经历过的那样，开发人员经常使用视频来创建更丰富的游戏玩法。
    • SKShapeNode：此节点允许您在屏幕上绘制形状。你可以画形状不同的复杂性，从矩形和圆圈到任何任意形状。


    要使用SKCropNode实现类似效果，请按照四个简单步骤操作：
    1.创建一个新的SKCropNode。默认情况下，此节点不显示任何内容；它只是容器节点。
    2.将一个或多个您喜欢的任何类型的子节点添加到裁剪节点：标签、精灵节点等。
    3.设置裁剪口罩。掩码也是一个节点，可以是任何类型，例如精灵节点或标签。掩码节点的内容应该具有透明和不透明的区域；
    不透明的区域将导致内容显示，而透明区域将导致隐藏或剪切内容。
    4.将裁剪节点添加到场景中。像任何其他节点一样，您需要将裁剪节点添加到场景中才能查看其内容。
