 异步函数
 
 加上async关键词 就可以吧一个函数生命为异步函数
 
 异步函数的 async 关键字会帮助编译器确保两件事情：

 1.它允许我们在函数体内部使用 await 关键字；

 2.它要求其他人在调用这个函数时，使用 await 关键字。


 “async 也扮演了这样一个角色，它要求在特定情况下对当前函数进行标记，这是对于开发者的一种明确的提示，表明这个函数有一些特别的性质：try/throw 代表了函数可以被抛出，而 await 则代表了函数在此处可能会放弃当前线程，它是程序的潜在暂停点。

 放弃线程的能力，意味着异步方法可以被“暂停”，这个线程可以被用来执行其他代码。如果这个线程是主线程的话，那么界面将不会卡顿。被 await 的语句将被底层机制分配到其他合适的线程，在执行完成后，之前的“暂停”将结束，异步方法从刚才的 await 语句后开始，继续向下执行。”


 
 
 “async let 被称为异步绑定，它在当前 Task 上下文中创建新的子任务，并将它用作被绑定的异步函数 (也就是 async let 右侧的表达式) 的运行环境。和 Task.init 新建一个任务根节点不同，async let 所创建的子任务是任务树上的叶子节点。被异步绑定的操作会立即开始执行，即使在 await 之前执行就已经完成，其结果依然可以等到 await 语句时再进行求值”
 
 小结：
 “异步函数：提供语法工具，使用更简洁和高效的方式，表达异步行为。

 结构化并发：提供并发的运行环境，负责正确的函数调度、取消和执行顺序以及任务的生命周期。

 actor 模型：提供封装良好的数据隔离，确保并发代码的安全。”
 
 
 
### await理解：
 
 “await 充当的角色，就是标记出一个潜在的暂停点 (suspend point)。在异步函数中，可能发生暂停的地方，编译器会要求我们明确使用 await 将它标记出来。除此之外，await 并没有其他更多的语义或是运行时的特性。当控制权回到异步函数中时，它会从之前停止的地方开始继续运行。但是“桃花依旧笑春风”的同时，“人面不知何处去”也会是一个事实：虽然部分状态，比如原来的输入参数等，在 await 前后会被保留，但是返回到当前异步函数时，它并不一定还运行在和之前同样的线程中，异步函数所在类型中的实例成员也可能发生了变化。await 是一个明确的标识，编译器强制我们写明 await 的意义，就是要警示开发者，await 两侧的代码会处在完全不同的世界中。

但另一方面，await 仅仅只是一个潜在的暂停点，而非必然的暂停点。实际上会不会触发“暂停”，需要看被调用的函数的具体实现和运行时提供的执行器是否需要触发暂停。很多的异步函数并不仅仅是异步函数，它们可能是某个 actor 中的同步函数，但作为 actor 的一部分运行，在外界调用时表现为异步函数。Swift 会保证这样的函数能切换到它们自己的 actor 隔离域里完成执行。关于这个话题，我们会在 actor 的章节中继续。


async/await 定义的异步函数，提供了一种直观的方式定义“未来”：可以认为异步函数将会返回未来某个时间点的值。如果我们希望表达的不是未来某一个时间点的值，而是未来一系列多个时间点的值，会需要使用一种新的表达方式，那就是异步序列 (Async Sequences)。


#### 结构化并发
如果要用一句话概括，那就是即使进行并发操作，也要保证控制流路径的单一入口和单一出口。程序可以产生多个控制流来实现并发，但是所有的并发路径在出口时都应该处于完成 (或取消) 状态，并合并到一起。

通过树的形式组织任务

- 一个任务具有它自己的优先级和取消标识，它可以拥有若干个子任务 (叶子节点) 并在其中执行异步函数。

- 当一个父任务被取消时，这个父任务的取消标识将被设置，并向下传递到所有的子任务中去。

- 无论是正常完成还是抛出错误，子任务会将结果向上报告给父任务，在所有子任务正常完成或者抛出之前，父任务是不会被完成的。”

#### 非结构化任务

- TaskGroup.addTask 和 async let - 创建结构化的子任务，继承优先级和本地值。

- Task.init - 创建非结构化的任务根节点，从当前任务中继承运行环境：比如 actor 隔离域，优先级和本地值等。

- Task.detached - 创建非结构化的任务根节点，不从当前任务中继承优先级和本地值等运行环境，完全新的游离任务环境。

